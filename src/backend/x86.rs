use std::{fs::File, io::{BufWriter, Write}, fmt, process::Command, path::Path};

use crate::ir::{self, Instruction, Tag, SymbolKey, Ref};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
enum Inst<'a> {
    mov(Val, Val),
    push(Val),
    pop(Val),
    call(&'a str),
    ret,
    not(Val),
    add(Val, Val)
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Val {
    None,
    Int(u64),
    Stack(u32),
    Data(u32),
    //eax,
    rbp,
    rax,
    rdx
}
use Inst::*;
use Val::*;
impl Val {
    fn is_reg(&self) -> bool {
        !matches!(self, None | Int(_) | Stack(_) | Data(_))
    }
    /// moves this value into the specified register if it isn't already in any register
    #[must_use = "Returns the existing or new register"]
    fn ensure_reg(self, w: &mut AsmWriter, reg: Val) -> Self {
        if self.is_reg() { self } else {
            w.inst(mov(reg, self));
            reg
        }
    }
    #[must_use = "Returns the existing register or rax"]
    fn ensure_rax(self, w: &mut AsmWriter) -> Self { self.ensure_reg(w, rax) }
}
impl fmt::Display for Val {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            None => panic!("Tried to write NoVal. Did the x86 backend try to use the result of a label/return?"),
            Int(i) => return write!(f, "{i}"),
            Stack(offset) => return write!(f, "dword ptr [rbp - {offset}]"),
            Data(index) => return write!(f, "data{index}"),
            //eax => "eax",
            rbp => "rbp",
            rax => "rax",
            rdx => "rdx"
        };

        write!(f, "{s}")
    }
}

const FILE_START: &[u8] = 
b"; ----------------------------------------------------------------------------------------
; This file was automatically generated by the Eyelang Compiler.
; ----------------------------------------------------------------------------------------

global main

section   .text
";

struct AsmWriter {
    w: BufWriter<File>,
    data: Vec<u8>,
    data_index: u32
}

impl AsmWriter {
    fn new(file: File) -> Self {
        let mut w = BufWriter::new(file);
        w.write_all(FILE_START).unwrap();
        Self {
            w,
            data: Vec::new(),
            data_index: 0,
        }
    }

    fn begin_func(&mut self, name: &str) {
        writeln!(self.w, "{name}:").unwrap();
    }

    fn label(&mut self, func: u32, block: u32) {
        writeln!(self.w, "label{func}_{block}:").unwrap();
    }

    fn inst(&mut self, inst: Inst) {
        use Inst::*;
        write!(self.w, "\t").unwrap();
        let mut w = |inst: &str, args: &[Val]| {
            write!(self.w, "{inst}").unwrap();
            if !args.is_empty() { write!(self.w, " ").unwrap(); }
            for (i, arg) in args.iter().enumerate() {
                if i != 0 {
                    write!(self.w, ", ").unwrap();
                }
                write!(self.w, "{arg}").unwrap();
            }
        };
        match inst {
            mov(a, b) => w("mov", &[a, b]),
            push(r) => w("push", &[r]),
            pop(r) => w("pop", &[r]),
            ret => w("ret", &[]),
            call(name) => write!(self.w, "call {name}").unwrap(),
            not(v) => w("NOT", &[v]),
            add(r, v) => w("add", &[r, v])
        }
        writeln!(self.w).unwrap();
    }

    fn data(&mut self, data: &[u8]) -> u32 {
        self.data.extend(format!("data{}: ", self.data_index).as_bytes());
        self.data.extend(data);
        self.data.push(b'\n');
        self.data_index += 1;
        self.data_index - 1
    }
}

impl Drop for AsmWriter {
    fn drop(&mut self) {
        self.w.write_all(b"\nsection .data\n").unwrap();
        self.w.write_all(&self.data).unwrap();
        //message:  db        \"Hello, World\", 10      ; note the newline at the end
    }
}

pub unsafe fn emit(module: &ir::Module, file: File) {
    let mut w = AsmWriter::new(file);

    for (index, func) in module.funcs.iter().enumerate() {
        gen_func(index as u32, func, &module.funcs, &mut w);
    }
}

pub fn assemble(asm: &Path, output: &Path) -> bool {
    let status = Command::new("nasm")
        .arg("-f")
        .arg("elf64")
        .arg(asm)
        .arg("-o")
        .arg(output)
        .status()
        .expect("Failed to invoke assembler");
    status.success()
}

unsafe fn gen_func(index: u32, func: &ir::FinalFunction, funcs: &[ir::FinalFunction], w: &mut AsmWriter) {
    let mut stack_pos: u32 = 0;
    if let Some(ir) = &func.ir {
        w.begin_func(&func.name);
        w.inst(push(rbp));

        let mut r = Vec::with_capacity(ir.inst.len());

        let mut offset: u32 = 0;

        let get_ref = |r: Ref, refs: &[Val]| {
            if let Some(v) = r.into_val() {
                match v {
                    ir::RefVal::True => Int(1),
                    ir::RefVal::False => Int(0),
                    ir::RefVal::Unit => Int(0),
                    ir::RefVal::Undef => Int(0),
                }
            } else {
                let r = r.into_ref().unwrap();
                refs[r as usize]
            }
        };

        for inst in &ir.inst {
            let Instruction { data, tag, ty: _, span: _, used: _ } = inst;
            let val = match *tag {
                Tag::BlockBegin => {
                    w.label(index, data.int32);
                    None
                }
                Tag::Ret => {
                    let val = get_ref(data.un_op, &r);
                    if val != rax {
                        w.inst(mov(rax, val));
                    }
                    w.inst(pop(rbp));
                    w.inst(ret);
                    None
                }
                Tag::Param => todo!(),
                Tag::Int => Int(data.int),
                Tag::LargeInt => todo!(),
                Tag::Float => todo!(),
                Tag::Decl => {
                    let current_offset = offset;
                    offset += 8;
                    Stack(current_offset)
                }
                Tag::Load => get_ref(data.un_op, &r),
                Tag::Store => {
                    let into = get_ref(data.bin_op.0, &r);
                    let val = get_ref(data.bin_op.1, &r);
                    
                    w.inst(mov(into, val));
                    None
                }
                Tag::String => {
                    let bytes = &ir.extra[
                        inst.data.extra_len.0 as usize
                        .. (inst.data.extra_len.0 + inst.data.extra_len.1) as usize
                    ];
                    Data(w.data(bytes))
                }
                Tag::Call => {
                    let start = data.extra_len.0 as usize;
                    let mut bytes = [0; 8];
                    bytes.copy_from_slice(&ir.extra[start..start+8]);
                    let func = SymbolKey::from_bytes(bytes);
                    let _refs = (0..data.extra_len.1).map(|i| {
                        let mut ref_bytes = [0; 4];
                        let begin = 8 + start + (4 * i) as usize;
                        ref_bytes.copy_from_slice(&ir.extra[begin..begin+4]);
                        Ref::from_bytes(ref_bytes)
                    });
                    let call_name = &funcs[func.idx()].name;
                    // TODO: move other values into appropriate registers
                    /*for (i, r) in refs.enumerate() {
                        if i != 0 {
                            s.push_str(", ");
                        }
                        s.push_str(&write_ref(r).to_string());
                    }*/
                    w.inst(call(call_name));
                    rax
                }
                Tag::Neg => {
                    let r = get_ref(data.un_op, &r).ensure_rax(w);
                    w.inst(not(r));
                    w.inst(add(r, Int(1)));
                    r
                }
                Tag::Not => todo!(),
                Tag::Add => {
                    let left = get_ref(data.bin_op.0, &r).ensure_rax(w);
                    w.inst(push(left));
                    let mut right = get_ref(data.bin_op.1, &r);
                    if right == rax {
                        // move into rdx because rax will be occupied by the left side
                        w.inst(mov(rdx, right));
                        right = rdx;
                    }
                    w.inst(pop(left));
                    w.inst(add(left, right));
                    left
                }
                Tag::Sub => todo!(),
                Tag::Mul => todo!(),
                Tag::Div => todo!(),
                Tag::Mod => todo!(),
                Tag::Or => todo!(),
                Tag::And => todo!(),
                Tag::Eq => todo!(),
                Tag::Ne => todo!(),
                Tag::LT => todo!(),
                Tag::GT => todo!(),
                Tag::LE => todo!(),
                Tag::GE => todo!(),
                Tag::Member => todo!(),
                Tag::Cast => todo!(),
                Tag::AsPointer => todo!(),
                Tag::Goto => todo!(),
                Tag::Branch => todo!(),
                Tag::Phi => todo!(),
                
            };
            w.inst(push(val));
            r.push(Stack(stack_pos));
            stack_pos += 8;
        }
    }
}