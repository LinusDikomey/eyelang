use std::{fs::File, io::{BufWriter, Write}, fmt, process::Command, path::Path};
use std::fmt::Write as _;

use crate::ir::{self, Instruction, Tag, SymbolKey, Ref};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
enum Inst<'a> {
    mov(Val, Val),
    push(Val),
    pop(Val),
    call(&'a str),
    ret,
    not(Val),
    add(Val, Val),
    sub(Val, Val)
}
use Inst::*;

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Val {
    None,
    Int(u64),
    Stack(u32),
    Data(u32),
    rsp,
    rbp,
    rax,
    rdi, rsi, rdx, rcx, r8, r9, // parameter registers
    al,
}
use Val::*;

impl Val {
    fn is_reg(&self) -> bool {
        !matches!(self, None | Int(_) | Stack(_) | Data(_))
    }
    /// moves this value into the specified register if it isn't already in any register
    #[must_use = "Returns the existing or new register"]
    fn ensure_reg(self, w: &mut AsmWriter, reg: Val) -> Self {
        if self.is_reg() { self } else {
            w.inst(mov(reg, self));
            reg
        }
    }
    #[must_use = "Returns the existing register or rax"]
    fn ensure_rax(self, w: &mut AsmWriter) -> Self { self.ensure_reg(w, rax) }
}
impl fmt::Display for Val {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            None => panic!("Tried to write NoVal. Did the x86 backend try to use the result of a label/return?"),
            Int(i) => return write!(f, "{i}"),
            Stack(offset) => return write!(f, "QWORD [rbp - {offset}]"),
            Data(index) => return write!(f, "QWORD data{index}"),
            rsp => "rsp",
            rbp => "rbp",
            rax => "rax",
            rdi => "rdi",
            rsi => "rsi",
            rdx => "rdx",
            rcx => "rcx",
            r8 => "r8",
            r9 => "r9",
            al => "al",
        };

        write!(f, "{s}")
    }
}

const FILE_START: &[u8] = 
b"\
; --------------------------------------------------------------
; This file was automatically generated by the Eyelang Compiler.
; --------------------------------------------------------------

";

fn name_modifier<'a>(name: &'a str) -> std::borrow::Cow<'a, str> {
    name.into()
}

struct AsmWriter {
    w: BufWriter<File>,
    content: String,
    data: Vec<u8>,
    data_index: u32
}

impl AsmWriter {
    fn new(file: File) -> Self {
        let mut w = BufWriter::new(file);
        w.write_all(FILE_START).unwrap();
        Self {
            w,
            content: String::new(),
            data: Vec::new(),
            data_index: 0,
        }
    }

    fn add_extern(&mut self, name: &str) {
        writeln!(self.w, "extern {}", name_modifier(name)).unwrap();
    }

    fn begin_func(&mut self, name: &str) {
        writeln!(self.content, "{}:", name_modifier(name)).unwrap();
    }

    fn label(&mut self, func: u32, block: u32) {
        writeln!(self.content, "label{func}_{block}:").unwrap();
    }

    fn inst(&mut self, inst: Inst) {
        use Inst::*;
        write!(self.content, "\t").unwrap();
        let mut w = |inst: &str, args: &[Val]| {
            write!(self.content, "{inst}").unwrap();
            if !args.is_empty() { write!(self.content, " ").unwrap(); }
            for (i, arg) in args.iter().enumerate() {
                if i != 0 {
                    write!(self.content, ", ").unwrap();
                }
                write!(self.content, "{arg}").unwrap();
            }
        };
        match inst {
            mov(a, b) => w("mov", &[a, b]),
            push(r) => w("push", &[r]),
            pop(r) => w("pop", &[r]),
            ret => w("ret", &[]),
            call(name) => write!(self.content, "call {name}").unwrap(),
            not(v) => w("not", &[v]),
            add(r, v) => w("add", &[r, v]),
            sub(r, v) => w("sub", &[r, v]),
        }
        writeln!(self.content).unwrap();
    }

    fn data(&mut self, data: &[u8]) -> u32 {
        self.data.extend(format!("data{}: db ", self.data_index).as_bytes());
        for byte in data {
            write!(self.data, "{}", byte).unwrap();
            write!(self.data, ", ").unwrap();
        }
        write!(self.data, "0\n").unwrap();
        self.data_index += 1;
        self.data_index - 1
    }
}

impl Drop for AsmWriter {
    fn drop(&mut self) {
        writeln!(self.w, "global {}", name_modifier("main")).unwrap();
        writeln!(self.w, "section   .text").unwrap();
        write!(self.w, "{}", self.content).unwrap();
        writeln!(self.w, "\nsection .data").unwrap();
        self.w.write_all(&self.data).unwrap();
    }
}

pub unsafe fn emit(module: &ir::Module, file: File) {
    let mut w = AsmWriter::new(file);

    for (index, func) in module.funcs.iter().enumerate() {
        gen_func(index as u32, func, &module.funcs, &mut w);
    }
}

pub fn assemble(asm: &Path, output: &Path) -> bool {
    let status = Command::new("nasm")
        .arg("-f")
        .arg("elf64")
        .arg(asm)
        .arg("-o")
        .arg(output)
        .status()
        .expect("Failed to invoke assembler");
    status.success()
}

const CALL_REGS: [Val; 6] = [rdi, rsi, rdx, rcx, r8, r9];
const CALL_STACK_ALIGNMENT: u32 = 16;

unsafe fn gen_func(index: u32, func: &ir::FinalFunction, funcs: &[ir::FinalFunction], w: &mut AsmWriter) {
    if let Some(ir) = &func.ir {
        w.begin_func(&func.name);
        w.inst(push(rbp));
        w.inst(mov(rbp, rsp));
        let mut r = Vec::with_capacity(ir.inst.len());
        
        let mut stack_pos: u32 = 0;
        
        let get_ref = |r: Ref, refs: &[Val]| {
            if let Some(v) = r.into_val() {
                match v {
                    ir::RefVal::True => Int(1),
                    ir::RefVal::False => Int(0),
                    ir::RefVal::Unit => Int(0),
                    ir::RefVal::Undef => Int(0),
                }
            } else {
                let r = r.into_ref().unwrap();
                refs[r as usize]
            }
        };

        for inst in &ir.inst {
            let Instruction { data, tag, ty: _, used: _ } = inst;
            let val = match *tag {
                Tag::BlockBegin => {
                    w.label(index, data.int32);
                    None
                }
                Tag::Ret => {
                    let val = get_ref(data.un_op, &r);
                    if val != rax {
                        w.inst(mov(rax, val));
                    }
                    w.inst(mov(rsp, rbp));
                    w.inst(pop(rbp));
                    w.inst(ret);
                    None
                }
                Tag::Param => {
                    let idx = data.int32;
                    assert!(idx < 6);
                    CALL_REGS[idx as usize]
                }
                Tag::Int => Int(data.int),
                Tag::LargeInt => todo!(),
                Tag::Float => todo!(),
                Tag::Decl => {
                    stack_pos += 8;
                    w.inst(sub(rsp, Int(8)));
                    r.push(Stack(stack_pos));
                    continue // value is already on the stack
                }
                Tag::Load => get_ref(data.un_op, &r),
                Tag::Store => {
                    let into = get_ref(data.bin_op.0, &r);
                    let val = get_ref(data.bin_op.1, &r);
                    let from = if matches!(into, Stack(_)) && matches!(val, Stack(_)) {
                        w.inst(mov(rax, val));
                        rax
                    } else {
                        val
                    };
                    w.inst(mov(into, from));
                    None
                }
                Tag::String => {
                    let bytes = &ir.extra[
                        inst.data.extra_len.0 as usize
                        .. (inst.data.extra_len.0 + inst.data.extra_len.1) as usize
                    ];
                    Data(w.data(bytes))
                }
                Tag::Call => {
                    let start = data.extra_len.0 as usize;
                    let mut bytes = [0; 8];
                    bytes.copy_from_slice(&ir.extra[start..start+8]);
                    let func = SymbolKey::from_bytes(bytes);
                    let refs = (0..data.extra_len.1).map(|i| {
                        let mut ref_bytes = [0; 4];
                        let begin = 8 + start + (4 * i) as usize;
                        ref_bytes.copy_from_slice(&ir.extra[begin..begin+4]);
                        Ref::from_bytes(ref_bytes)
                    });
                    let func = &funcs[func.idx()];
                    let call_name = &func.name;
                    let arg_count = refs.len();
                    assert!(arg_count <= 6, "More than 6 arguments not supported right now");
                    for (ref_val, reg) in refs.take(6).zip(CALL_REGS) {
                        let _ = get_ref(ref_val, &r).ensure_reg(w, reg);
                    }
                    if func.varargs {
                        let vararg_count = arg_count - func.params.len();
                        w.inst(mov(al, Int(vararg_count as u64)));
                    }
                    // align the stack to the required alignment before calling
                    let missing_alignment = (CALL_STACK_ALIGNMENT - (stack_pos % CALL_STACK_ALIGNMENT)) as u64;
                    w.inst(sub(rsp, Int(missing_alignment)));
                    w.inst(call(&name_modifier(call_name)));
                    // move back the stack pointer
                    w.inst(add(rsp, Int(missing_alignment)));
                    rax
                }
                Tag::Neg => {
                    let r = get_ref(data.un_op, &r).ensure_rax(w);
                    w.inst(not(r));
                    w.inst(add(r, Int(1)));
                    r
                }
                Tag::Not => todo!(),
                Tag::Add => {
                    let left = get_ref(data.bin_op.0, &r).ensure_rax(w);
                    w.inst(push(left));
                    let mut right = get_ref(data.bin_op.1, &r);
                    if right == rax {
                        // move into rdx because rax will be occupied by the left side
                        w.inst(mov(rdx, right));
                        right = rdx;
                    }
                    w.inst(pop(left));
                    w.inst(add(left, right));
                    left
                }
                Tag::Sub => todo!(),
                Tag::Mul => todo!(),
                Tag::Div => todo!(),
                Tag::Mod => todo!(),
                Tag::Or => todo!(),
                Tag::And => todo!(),
                Tag::Eq => todo!(),
                Tag::Ne => todo!(),
                Tag::LT => todo!(),
                Tag::GT => todo!(),
                Tag::LE => todo!(),
                Tag::GE => todo!(),
                Tag::Member => todo!(),
                Tag::Cast => todo!(),
                Tag::AsPointer => todo!(),
                Tag::Goto => todo!(),
                Tag::Branch => todo!(),
                Tag::Phi => todo!(),
                
            };
            if inst.used && val != None {
                if val.is_reg() {
                    w.inst(push(val));
                    stack_pos += 8;
                    r.push(Stack(stack_pos));
                } else {
                    r.push(val);
                }
                
            } else {
                r.push(None)
            }
        }
    } else {
        w.add_extern(&func.name);
    }
}