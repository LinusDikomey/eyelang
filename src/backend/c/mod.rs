use std::fs::File;
use std::io::Write;

use crate::ir::types::{IrType, TypeRef};
use crate::ir::{Function, Tag, Ref, FunctionId, Module, FunctionIr};
use crate::resolve::types::Type;
use crate::types::Primitive;

const FILE_START: &str = "\
///////////////////////////////////////////////////////////////////////////////
////////// THIS FILE WAS AUTOMATICALLY GENERATED BY THE EYE COMPILER //////////
///////////////////////////////////////////////////////////////////////////////
#include <stdint.h>
";

type Result<T> = std::result::Result<T, std::io::Error>;

pub fn emit(module: &Module, mut file: File) -> Result<()> {
    writeln!(file, "{}\n////////// globals //////////", FILE_START)?;
    for (name, ty, val) in &module.globals {
        write_type(&mut file, ty)?;
        write!(&file, " {}", name)?;
        if let Some(_val) = val {
            write!(file, " = ")?;
            todo!("globals with value");
        }
        writeln!(file, ";")?;
    }
    writeln!(file, "\n////////// function predeclarations //////////")?;
    for function in &module.funcs {
        func_head(&mut file, function)?;
        writeln!(file, ";")?;
    }
    writeln!(file, "\n////////// functions //////////")?;
    for function in &module.funcs {
        func(&mut file, module, function)?;
    }
    Ok(())
}

fn write_type<W: Write>(f: &mut W, ty: &Type) -> Result<bool> {
    match ty {
        Type::Prim(p) => return primitive(f, *p),
        Type::Id(_, _) => todo!(),
        Type::Pointer(inner) => {
            write_type(f, inner)?;
            write!(f, "*")?;
        }
        Type::Array(_) => todo!(),
        Type::Tuple(_) => todo!(),
        Type::Generic(_) => todo!(),
        Type::LocalEnum(_) => todo!(),
        Type::TraitSelf => unreachable!(),
        Type::Invalid => todo!(),
    }
    Ok(true)
}
fn primitive<W: Write>(f: &mut W, p: Primitive) -> Result<bool> {
    let s = match p {
        Primitive::I8 => "int8_t",
        Primitive::U8 | Primitive::Bool => "uint8_t",
        Primitive::I16 => "int16_t",
        Primitive::U16 => "uint16_t",
        Primitive::I32 => "int32_t",
        Primitive::U32 => "uint32_t",
        Primitive::I64 => "int64_t",
        Primitive::U64 => "uint64_t",
        Primitive::I128 => "int128_t",
        Primitive::U128 => "uint128_t",
        Primitive::F32 => "float",
        Primitive::F64 => "double",
        Primitive::Unit | Primitive::Never | Primitive::Type => return Ok(false),
    };
    write!(f, "{}", s)?;
    Ok(true)
}

fn func_head(file: &mut File, func: &Function) -> Result<()> {
    if matches!(func.return_type, Type::Prim(Primitive::Unit | Primitive::Never | Primitive::Type)) {
        write!(file, "void")?;
    } else {
        write_type(file, &func.return_type)?;
    }
    write!(file, " {}(", func.name)?;
    for (i, (name, ty)) in func.params.iter().enumerate() {
        if i != 0 {
            write!(file, ", ")?;
        }
        write_type(file, ty)?;
        write!(file, " {}", name)?;
    }
    write!(file, ")")
}

fn func(file: &mut File, module: &Module, func: &Function) -> Result<()> {
    let Some(ir) = &func.ir else { return Ok(()) };

    func_head(file, func)?;
    writeln!(file, " {{")?;
    /// writes a reference
    fn r(file: &mut File, ir: &FunctionIr, r: Ref) -> Result<()> {
        if let Some(val) = r.into_val() {
            use crate::ir::RefVal;
            match val {
                RefVal::True => write!(file, "1"),
                RefVal::False => write!(file, "0"),
                RefVal::Unit => panic!(),
                RefVal::Undef => panic!(),
            }
        } else {
            let r = r.into_ref().unwrap();
            if ir.inst[r as usize].tag == Tag::Decl {
                write!(file, "&_{}", r)
            } else {
                write!(file, "_{}", r)
            }
        }
    }
    fn local_ty<W: Write>(ir: &FunctionIr, f: &mut W, ty: TypeRef) -> Result<bool> {
        match ir.types[ty] {
            IrType::Primitive(Primitive::Unit | Primitive::Never | Primitive::Type) => return Ok(false),
            IrType::Primitive(p) => return primitive(f, p),
            IrType::Ptr(inner) => {
                local_ty(ir, f, inner)?;
                write!(f, "*")?;
            }
            _ => todo!(),
        };
        Ok(true)
    }
    for (i, inst) in ir.inst.iter().enumerate() {
        match inst.tag {
            Tag::BlockBegin => {
                writeln!(file, "  block{}:", unsafe { inst.data.block }.idx())?;
            }
            Tag::Goto => {
                writeln!(file, "    goto block{};", unsafe { inst.data.block }.idx())?;
            }
            Tag::Param => {
                write!(file, "    ")?;
                let idx = unsafe { inst.data.int32 } as usize;
                if write_type(file, &func.params[idx].1)? {
                    writeln!(file, " _{} = {};", i, func.params[idx].0)?;
                }
            }
            Tag::Decl => {
                let mut ty = Vec::new();
                if local_ty(ir, &mut ty, unsafe { inst.data.ty })? {
                    write!(file, "    ")?;
                    file.write_all(&ty)?;
                    writeln!(file, " _{};", i)?;
                }
            }
            Tag::Load => {
                let mut ty = Vec::new();
                if local_ty(ir, &mut ty, inst.ty)? {
                    write!(file, "    ")?;
                    file.write_all(&ty)?;
                    let v = unsafe { inst.data.un_op };
                    write!(file, " _{} = *", i)?;
                    r(file, ir, v)?;
                    writeln!(file, ";")?;
                }
            }
            Tag::Store => {
                let (a, b) = unsafe { inst.data.bin_op };
                let store_idx = a.into_ref().unwrap();
                if local_ty(ir, &mut Vec::new(), ir.inst[store_idx as usize].ty)? {
                    if ir.inst[store_idx as usize].tag == Tag::Decl {
                        write!(file, "    _{} = ", store_idx)?;
                    } else {
                        write!(file, "    *_{} = ", store_idx)?;
                    }
                    r(file, ir, b)?;
                    writeln!(file, ";")?;
                }
            }
            Tag::Branch => {
                let (cond, i) = unsafe { inst.data.ref_int };
                let i = i as usize;
                write!(file, "    if (")?;
                r(file, ir, cond)?;
                let mut bytes = [0; 4];
                bytes.copy_from_slice(&ir.extra[i..i+4]);
                let a = u32::from_le_bytes(bytes);
                write!(file, ") goto block{};", a)?;
                bytes.copy_from_slice(&ir.extra[i+4..i+8]);
                let b = u32::from_le_bytes(bytes);
                writeln!(file, " else goto block{};", b)?;
            }
            Tag::Int => {
                write!(file, "    ")?;
                let IrType::Primitive(p) = ir.types[inst.ty] else { panic!() };
                debug_assert!(p.is_int());
                primitive(file, p)?;
                writeln!(file, " _{} = {};", i, unsafe { inst.data.int })?;
            }
            Tag::Float => {
                write!(file, "    ")?;
                let IrType::Primitive(p) = ir.types[inst.ty] else { panic!() };
                debug_assert!(p.is_float());
                primitive(file, p)?;
                writeln!(file, " _{} = {};", i, unsafe { inst.data.float })?;
            }
            Tag::Add | Tag::Sub | Tag::Mul | Tag::Div | Tag::Mod | Tag::Eq | Tag::NE | Tag::And | Tag::Or => {
                write!(file, "    ")?;
                let IrType::Primitive(p) = ir.types[inst.ty] else { panic!() };
                assert!(primitive(file, p)?);
                let (a, b) = unsafe { inst.data.bin_op };
                write!(file, " _{} = ", i)?;
                r(file, ir, a)?;
                let op = match inst.tag {
                    Tag::Add => "+",
                    Tag::Sub => "-",
                    Tag::Mul => "*",
                    Tag::Div => "/",
                    Tag::Mod => "%",
                    Tag::Eq => "==",
                    Tag::NE => "!=",
                    Tag::And => "&&",
                    Tag::Or => "||",
                    _ => unreachable!(),
                };
                write!(file, " {} ", op)?;
                r(file, ir, b)?;
                writeln!(file, ";")?;
            }
            Tag::Call => {
                let (start, refs) = unsafe { inst.data.extra_len };
                write!(file, "    ")?;
                if local_ty(ir, file, inst.ty)? {
                    write!(file, " _{} = ", i)?;
                }
                let start = start as usize;
                let mut bytes = [0; 8];
                bytes.copy_from_slice(&ir.extra[start..start+8]);
                let func = FunctionId::from_bytes(bytes);
                let called = &module.funcs[func.idx()];
                write!(file, "{}(", called.name)?;
                
                for i in 0..refs {
                    if i != 0 {
                        write!(file, ", ")?;
                    }
                    let mut ref_bytes = [0; 4];
                    let begin = 8 + start + (4 * i) as usize;
                    ref_bytes.copy_from_slice(&ir.extra[begin..begin+4]);
                    r(file, ir, Ref::from_bytes(ref_bytes))?;
                }

                writeln!(file, ");")?;
            }
            Tag::Ret => {
                let value = unsafe { inst.data.un_op };
                if value == Ref::UNDEF {
                    writeln!(file, "    return;")?;
                } else {
                    write!(file, "    return ")?;
                    r(file, ir, unsafe { inst.data.un_op })?;
                    writeln!(file, ";")?;
                }
            }
            _ => todo!("tag {}", inst.tag),

        }
    }
    writeln!(file, "}}")?;
    Ok(())
}


